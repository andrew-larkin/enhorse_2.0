## JVM
+ [За что отвечает JVM](#За-что-отвечает-jvm)
+ [Garbage Collectors](#Garbage-collectors)
+ [GC Реализации](#Gc-реализации)
+ [Classloader](jvm.md#сlassloader)
+ [Области данных времени выполнения](jvm.md#Области-данных-времени-выполнения)
+ [Frames](jvm.md#Frames)
+ [Execution Engine](jvm.md#Execution-Engine)
+ [Полезные ссылки](jvm.md#Полезные-ссылки)

## За что отвечает _JVM_:

+ Загрузка, проверка и исполнение байт кода;
+ Предоставление среды выполнения для выполнения байт-кода;
+ Управление памятью и очисткой мусора (Garbage collection);

Виртуальная машина Java (Java Virtual Machine) - это механизм, предоставляющий среду выполнения для управления Java-кодом или приложениями.
Виртуальная машина является независимой оболочкой исполнения кода, благодаря которой возможен её запуск на любой ОС,
без влияния ОС на выполняемую программу. 

JVM работает с 2мя типами данных:  примитивные типы (**primitive types**) и ссылочные типы (**reference types**).

**Примитивы**

JVM работает с примитивными значениями (целыми числами и числами с плавающей точкой). По сути, JVM - это 32-битная машина. 
Типы `long` и `double`, которые являются 64-битными, поддерживаются изначально, но занимают две единицы памяти в `frame's local` 
или стеке операндов, поскольку каждая единица составляет 32 бита.
Типы `boolean`, `byte`, `short` и `char` имеют расширенный знак (кроме `char` с нулевым расширением) и работают как 32-разрядные целые числа, так же, как и типы `int`.
Меньшие типы имеют только несколько специфических для типа инструкций для загрузки, хранения и преобразования типов.
`boolean` значение работает как 8-битное `byte` значения, где 0 представляет значение **false**, а 1 - значение **true**.

**Типы ссылок и значения**

Существует три типа ссылочных типов: типы классов, типы массивов и типы интерфейсов.
Их значения являются ссылками на динамически создаваемые экземпляры классов, массивы или экземпляры классов, 
которые реализуют интерфейсы соответственно.

[к оглавлению](#jvm)

## Garbage Collectors:

Garbage Collection отслеживает каждый объект, доступный в JVM heap space, и удаляет неиспользуемые.

По сути, GC работает в два простых этапа, известных как маркировка (Mark) и очистка (Sweep):

Mark — здесь сборщик мусора определяет, какие фрагменты памяти используются, а какие нет.
Sweep – на этом этапе удаляются объекты, идентифицированные на этапе «отметки».

**Преимущества**:

+ Никакой ручной обработки выделения/освобождения памяти, поскольку неиспользуемое пространство памяти автоматически обрабатывается сборщиком мусора.
+ Никаких накладных расходов на обработку Dangling Pointer.
+ Автоматическое управление утечками памяти (GC сам по себе не может гарантировать полное решение проблемы утечки памяти, однако он позаботится о значительной ее части)

**Недостатки**:

+ Поскольку JVM должна отслеживать создание/удаление ссылок на объекты, это действие требует больше мощности процессора, чем исходное приложение. Это может повлиять на производительность запросов, требующих большого объема памяти.
+ Программисты не могут контролировать планирование времени ЦП, выделяемого на освобождение объектов, которые больше не нужны.
+ Использование некоторых реализаций GC может привести к непредсказуемой остановке приложения.
+ Автоматизированное управление памятью не будет таким эффективным, как правильное выделение/освобождение памяти вручную.


[к оглавлению](#jvm)


## GC Реализации:

+ **Serial Garbage Collector**

Это простейшая реализация GC, поскольку она в основном работает с одним потоком. В результате эта реализация GC замораживает все потоки приложения при запуске. Поэтому не рекомендуется использовать его в многопоточных приложениях, например в серверных средах.
Serial GC — лучший сборщик мусора для большинства приложений, которые не требуют небольшого времени паузы и работают на машинах клиентского типа. 
Чтобы включить последовательный сборщик мусора, мы можем использовать следующий аргумент:
```code
-XX:+UseSerialGC 
```

+ **Parallel Garbage Collector**

Это стандартный сборщик мусора JVM от Java 5 до Java 8, который иногда называют Throughput Collectors. 
В отличие от Serial GC, он использует несколько потоков для управления heap space, но также замораживает другие потоки 
приложений во время выполнения сборки мусора.

Если мы используем этот сборщик мусора, мы можем указать максимальное количество потоков сборки мусора, 
а также время паузы, пропускную способность и занимаемую площадь (footprint) (размер кучи).

+ Количество потоков сборщика мусора можно контролировать с помощью параметра командной строки -XX:ParallelGCThreads=<N>;

+ Максимальное целевое время паузы (подсказка сборщику мусора о том, что желательно иметь время паузы <N> миллисекунд или меньше) указывается с помощью параметра командной строки -XX:MaxGCPauseMillis=<N>.

+ Время, затраченное на сбор мусора, по сравнению со временем, затраченным вне сбора мусора, называется максимальной целевой пропускной способностью и может быть указано с помощью параметра командной строки -XX:GCTimeRatio=<N>.

+ Максимальный размер кучи (объем динамической памяти, который требуется программе во время работы) указывается с помощью опции -Xmx<N>.

To enable Parallel Garbage Collector, we can use the following argument:
```code
-XX:+UseParallelGC
```

+ **Parallel Garbage Collector**

Сборщик Concurrent Mark Sweep (CMS) предназначен для приложений, которые предпочитают более короткие паузы при 
сборке мусора и могут позволить себе использовать ресурсы процессора совместно со сборщиком мусора во время работы 
приложения. Обычно от использования этого сборщика выигрывают приложения, которые имеют относительно большой набор 
долгоживущих данных (большое постоянное поколение large tenured generation) и работают на машинах с двумя или 
более процессорами. Однако этот коллектор следует рассматривать для любого приложения с минимальными требованиями 
к времени паузы. 

Сборщик CMS включается с помощью параметра командной строки 
```code
-XX:+UseConcMarkSweepGC
```


+ **G1 Garbage Collector**

G1 (Garbage First) Сборщик мусора предназначен для приложений, работающих на многопроцессорных машинах с большим объемом памяти. Он доступен в JDK7 Update 4 и в более поздних выпусках.

В отличие от других сборщиков, сборщик G1 разделяет кучу на набор областей кучи одинакового размера, каждая из которых 
представляет собой непрерывный диапазон виртуальной памяти. При выполнении сборки мусора G1 показывает 
параллельную фазу глобальной маркировки concurrent global marking phase (phase 1,, известную как Marking) для определения 
жизнеспособности объектов в куче.

После завершения фазы маркировки G1 узнает, какие регионы в основном пусты. Сначала он собирается в этих областях, 
что обычно дает значительное количество свободного пространства (т. е. phase 2, известная как Sweeping). 
Вот почему этот метод сбора мусора называется Garbage-First.

Чтобы включить сборщик мусора G1, мы можем использовать следующий аргумент:
```code
-XX:+UseG1GC
```


В Java 8u20 появился еще один параметр JVM для уменьшения ненужного использования памяти за счет создания слишком 
большого количества экземпляров одной и той же строки. Это оптимизирует память кучи, удаляя повторяющиеся значения 
String в глобальный одиночный массив char[].
Мы можем включить этот параметр, добавив -XX:+UseStringDeduplication в качестве параметра JVM.

+ **Z Garbage Collector**

ZGC (Z Garbage Collector) — это масштабируемый сборщик мусора с малой задержкой (low-latency).
ZGC получила статус production, начиная с Java 15.

ZGC выполняет всю дорогостоящую работу одновременно, не останавливая выполнение потоков приложения более чем на 10 мс, 
что делает его подходящим для приложений, требующих малой задержки. Он использует барьеры нагрузки (load barriers)
с цветными указателями для выполнения параллельных операций во время работы потоков, а также для отслеживания использования кучи.

Reference coloring  (цветные указатели) — это основная концепция ZGC. Это означает, что ZGC использует некоторые биты 
(биты метаданных) ссылки для обозначения состояния объекта. Он также обрабатывает кучи размером от 8 МБ до 16 ТБ. 
Более того, время паузы не увеличивается с увеличением размера кучи, живого набора или корневого набора.

Подобно G1, сборщик мусора Z разделяет кучу, за исключением того, что области кучи могут иметь разные размеры.

```code
-XX:+UseZGC
```
<img src="/images/heap_space.jpg">

[к оглавлению](#jvm)

## Classloader

Загрузчик классов является частью JRE, которая динамически загружает Java классы в JVM. 
Обычно классы загружаются только по запросу. Система исполнения в Java не должна знать о файлах и файловых системах
благодаря загрузчику классов. **Делегирование является важной концепцией**, которую выполняет загрузчик. Загрузчик классов 
отвечает за поиск библиотек, чтение их содержимого и загрузку классов, содержащихся в библиотеках. 
Эта **загрузка** обычно выполняется **«по требованию»**, поскольку она не происходит до тех пор, пока программа не вызовет класс.
**Класс с именем может быть загружен только один раз данным загрузчиком классов.**

При запуске JVM, используются три загрузчика классов:
* Bootstrap class loader (Загрузчик класса Bootstrap)
* Extensions class loader (Загрузчик класса расширений)
* System class loader (Системный загрузчик классов)

**Загрузчик класса Bootstrap** загружает основные библиотеки Java, расположенные в папке `<JAVA_HOME>/jre/lib`. 
Этот загрузчик является частью ядра JVM, написан на нативном коде.

**Загрузчик класса расширений** загружает код в каталоги расширений 
(`<JAVA_HOME>/jre/lib/ext`, или любой другой каталог, указанный системным свойством `java.ext.dirs`).

**Системный загрузчик** загружает код, найденный в `java.class.path`, который сопоставляется с переменной среды `CLASSPATH`.
Это реализуется классом `sun.misc.Launcher$AppClassLoader`.

Загрузчик классов выполняет три основных действия в строгом порядке: 
* Загрузка: находит и импортирует двоичные данные для типа. 
* Связывание: выполняет проверку, подготовку и (необязательно) разрешение. 
    - Проверка: обеспечивает правильность импортируемого типа. 
    - Подготовка: выделяет память для переменных класса и инициализация памяти значениями по умолчанию. 
    - Разрешение: преобразует символические ссылки из типа в прямые ссылки. 
* Инициализация: вызывает код Java, который инициализирует переменные класса их правильными начальными значениями.

**Пользовательский загрузчик классов**

Загрузчик классов написан на Java. Поэтому возможно создать свой собственный загрузчик классов, не понимая тонких деталей JVM.
У каждого загрузчика классов Java есть родительский загрузчик классов, определенный при создании экземпляра нового 
загрузчика классов или в качестве системного загрузчика классов по умолчанию для виртуальной машины.

Что делает возможным следующее:
* загружать или выгружать классы во время выполнения (например, динамически загружать библиотеки во время выполнения, даже из ресурса HTTP).
Это важная особенность для:
    - реализация скриптовых языков;
    - использование bean builders;
    - добавить пользовательское расширение;
    - позволяя нескольким пространствам имен общаться. Например, это одна из основ протоколов CORBA / RMI;
* изменить способ загрузки байт-кода (например, можно использовать зашифрованный байт-код класса Java);
* модифицировать загруженный байт-код (например, для переплетения аспектов во время загрузки при использовании аспектно-ориентированного программирования);

[к оглавлению](#jvm)

## Области данных времени выполнения

Run-Time Data Areas. JVM выделяет множество областей данных во время выполнения, которые используются во время выполнения программы. Некоторые участки данных
созданы JVM во время старта и уничтожаются во время её выключения. Другие создаются для каждого потока и уничтожаются, когда поток уничтожается.

**The pc Register (PCR)**

Виртуальная машина Java может поддерживать много потоков исполнения одновременно. Каждый поток виртуальной машины Java имеет свой собственный регистр PC (program counter).
В любой момент каждый поток виртуальной машины Java выполняет код одного метода, а именно текущий метод для этого потока.
Если этот метод не является native, регистр pc содержит адрес инструкции виртуальной машины Java, выполняемой в настоящее время.

Коротко говоря: для одного потока, существует один PCR, который создается при запуске потока. PCR хранит адрес выполняемой сейчас инструкции JVM.

**Java Virtual Machine Stacks**

Каждый поток в JVM имеет собственный стек, созданный одновременно с потоком.  Стек в JVM хранит frames. 
Cтеки в JVM могут иметь фиксированный размер или динамически расширяться и сжиматься в соответствии с требованиями вычислений.

**Heap**

JVM имеет heap (кучу), которая используется всеми потоками виртуальной машины Java. 
Куча - это область данных времени выполнения, из которой выделяется память для всех экземпляров и массивов классов.
Куча создается при запуске виртуальной машины. Хранилище для объектов восстанавливается автоматической системой 
управления данными (известной как сборщик мусора); объекты никогда не освобождаются явно. 
JVM не предполагает какого-либо конкретного типа системы автоматического управления хранением данных, 
и метод управления может быть выбран в соответствии с системными требованиями разработчика. 
Куча может иметь фиксированный размер или может быть расширена в соответствии с требованиями вычислений и может быть сокращена, 
если большая куча становится ненужной. Память для кучи не должна быть смежной.

**Method Area**

JVM имеет область методов, которая является общей для всех потоков. Она хранит структуры для каждого класса, такие как пул констант, данные полей и методов, 
а также код для методов и конструкторов, включая специальные методы, используемые при инициализации классов и экземпляров, и инициализации интерфейса.
Хотя область метода является логически частью кучи, простые реализации могут не обрабатываться сборщиком мусора. Область метода может иметь 
фиксированный размер или может быть расширена в соответствии с требованиями вычислений и может быть сокращена, если большая область метода становится ненужной.

**Run-Time Constant Pool**

 A run-time constant pool существует для каждого класса или интерфейса в рантайме и представленно constant_pool таблицей в *.class файле.
 Он содержит несколько видов констант: от числовых литералов, известных во время компиляции, до ссылок на методы и поля, 
 которые должны быть разрешены во время выполнения.  Сам run-time constant pool выполняет функцию,
 аналогичную функции таблицы символов для обычного языка программирования, хотя он содержит более широкий диапазон данных, чем типичная таблица символов.
 Каждый run-time constant pool отделён от JVM's method area. JVM создаёт run-time constant pool вместе с созданием class или interface.
 
**Native Method Stacks**

Реализация виртуальной машины Java может использовать обычные стеки, обычно называемые «стеки Си», для поддержки native methods (методов, написанных на языке, отличном от языка программирования Java).

[к оглавлению](#jvm)

## Frames

Frame используется для хранения данных и частичных результатов, а также для выполнения динамического связывания, возврата значений для методов и отправки исключений.
Новый frame создается каждый раз, когда вызывается метод. Frame уничтожается, когда завершается вызов метода, 
является ли это завершение нормальным или резким (он генерирует неперехваченное исключение). Frames выделяются из стека потока, создающего frame. 
Каждый frame имеет свой собственный массив локальных переменных, свой собственный стек операндов и ссылку на пул констант во время выполнения класса текущего метода.
Размеры массива локальных переменных и стека операндов определяются во время компиляции и предоставляются вместе с кодом для метода, связанного с фреймом.
Таким образом, размер структуры данных, frame-а зависит только от реализации виртуальной машины Java, и память для этих структур может быть выделена одновременно при вызове метода.

Только один frame активен в любой точке данного потока управления - метода выполнения, и это frame называется текущим, а его метод известен как текущий метод.
Класс, в котором определен текущий метод, является текущим классом. Операции над локальными переменными и стеком операндов обычно выполняются со ссылкой на текущий frame.

Frame перестает быть текущим, если его метод вызывает другой метод или если его метод завершается. Когда метод вызывается, новый frame создается и становится текущим, 
когда управление переходит к новому методу. При возврате метода текущий frame передает результат вызова метода, если таковой имеется, в предыдущий frame. 
Текущий frame затем отбрасывается, так как предыдущий frame становится текущим. Обратите внимание, что frame, созданный потоком, 
является локальным для этого потока и на него не может ссылаться ни один другой поток.

**Локальные переменные**

Каждый frame содержит массив переменных, известных как его локальные переменные. Длина массива локальных переменных frame определяется во время компиляции 
и предоставляется в двоичном представлении класса или интерфейса вместе с кодом для метода, связанного с frame-ом.
Единичная локальная переменная может хранить значение типа: boolean, byte, char, short, int, float, reference, or returnAddress. 
Пара локальных переменных может хранить значение типов: long или double.

Локальные переменные адресуются путем индексации. Индекс первой локальной переменной равен нулю.

Значение типа long или типа double занимает две последовательные локальные переменные.

JVM использует локальные переменные для передачи параметров при вызове метода. При вызове метода класса все параметры передаются в последовательных локальных переменных, 
начиная с локальной переменной 0. При вызове метода экземпляра локальная переменная 0 всегда используется для передачи ссылки на объект,
для которого вызывается метод экземпляра (this в Java). Любые параметры впоследствии передаются в последовательных локальных переменных, начиная с локальной переменной 1.
 
**Стеки операндов (Operand Stacks)**

Каждый frame содержит стек «последний вошел - первый вышел» (LIFO), известный как стек операндов. Максимальная глубина стека операндов frame-a
определяется во время компиляции и предоставляется вместе с кодом для метода, связанного с frame-ом.

Стек операнда пуст при создании frame-a, который его содержит. JVM предоставляет инструкции для загрузки констант 
или значений из локальных переменных или полей в стек операндов. Другие инструкции JVM берут операнды из стека операндов, 
оперируют с ними и помещают результат обратно в стек операндов. Стек операндов также используется для подготовки параметров 
для передачи в методы и для получения результатов метода.

Для примера, инструкция **iadd**  суммирует два int-вых значения. От стека операндов требуется, чтобы два int-вых значения были наверху стека.
Значения удаляются из стека, операция **pop**. Суммируются и их сумма помещается в стек операндов.

**Динамическое связывание (Dynamic Linking)**

Каждый frame содержит ссылку на  run-time constant pool для типа текущего метода для поддержки динамического связывания кода метода.
Доступ к вызываемым методам и переменным осуществляется через символические ссылки из class файла.
Динамическое связывание преобразует эти символьные ссылки на методы в конкретные ссылки на методы, загружая классы по мере необходимости 
для разрешения пока еще не определенных символов, и преобразует обращения к переменным в соответствующие смещения в структурах хранения, 
связанных с расположением этих переменных во время выполнения.

Позднее связывание методов и переменных вносит изменения в другие классы, которые метод использует с меньшей вероятностью нарушить этот код.

**Нормальное завершение вызова метода**

Вызов метода завершается нормально, если этот вызов не вызывает исключение, либо непосредственно из JVM, либо в результате выполнения явного оператора throw. 
Если вызов текущего метода завершается нормально, то значение может быть возвращено вызывающему методу. 
Это происходит, когда вызванный метод выполняет одну из инструкций возврата, выбор которых должен соответствовать типу возвращаемого значения (если оно есть).

Текущий frame используется в этом случае для восстановления состояния инициатора, включая его локальные переменные и стек операндов, 
с соответствующим образом увеличенным программным счетчиком инициатора, чтобы пропустить инструкцию вызова метода. 
Затем выполнение обычно продолжается в frame вызывающего метода с возвращенным значением (если оно есть), помещаемым в стек операндов этого frame.

**Резкое завершение вызова метода**

Вызов метода завершается преждевременно, если при выполнении инструкции JVM в методе выдает исключение, и это исключение не обрабатывается в методе.
Выполнение команды **throw** также приводит к явному выбрасыванию исключения, и, если исключение не перехватывается текущим методом, 
приводит к неожиданному завершению вызова метода. Вызов метода, который завершается внезапно, никогда не возвращает значение своему вызывающему.

[к оглавлению](#jvm)

## Execution Engine

Байт-код, назначенный **run-time data areas**, будет выполнен **execution engine**. Механизм выполнения считывает байт-код и выполняет его по частям.

**Interpreter**

Интерпретатор интерпретирует байт-код быстро, но выполняется медленно. Недостаток интерпретатора заключается в том, что, когда один метод вызывается несколько раз, каждый раз требуется новая интерпретация.

**JIT Compiler**

JIT-компилятор устраняет недостатки интерпретатора. Механизм выполнения будет использовать помощь интерпретатора при преобразовании байт-кода, 
но когда он находит повторный код, он использует JIT-компилятор, который компилирует весь байт-код и изменяет его на собственный код. 
Этот нативный код будет использоваться непосредственно для повторных вызовов методов, которые улучшают производительность системы.

+ Генератор промежуточного кода (Intermediate Code Generator). Производит промежуточный код.
+ Code Optimizer. Отвечает за оптимизацию промежуточного кода, сгенерированного выше.
+ Генератор целевого кода (Target Code Generator). Отвечает за генерацию машинного кода или родной код.
+ Профилировщик (Profiler). Специальный компонент, отвечающий за поиск горячих точек, то есть, вызывается ли метод несколько раз или нет.

**Garbage Collector**

[к оглавлению](#jvm)

## Полезные ссылки:
- https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html
- https://www.developer.com/java/data/understanding-the-jvm-architecture.html
- https://dzone.com/articles/understanding-jvm-internals

[к оглавлению](#jvm)
