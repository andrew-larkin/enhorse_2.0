[Назад](../patternsmenu.md)

# User Interfaces
+ [Определение](#Определение)
+ [S - Single Responsibility Principle](#S---Single-Responsibility-Principle)
+ [O - Open closed Principle](#O---Open-closed-Principle)
+ [L - Liskov substitution Principle](#L---Liskov-substitution-Principle)
+ [I -  Interface Segregation Principle](#I---Interface-Segregation-Principle)
+ [D - Dependency Inversion Principle](#D---Dependency-Inversion-Principle)

## Определение

Пользовательские интерфейсы - место, где объединяются различные аспекты возможностей, предлагаемые пользователям. 
Проблема объединения этих аспектов рассматривается с двух сторон: кто и как. Во-первых, существуют организационные аспекты: 
кто несет какие обязанности, когда дело доходит до предоставления пользовательских интерфейсов. Во-вторых, мы существует
набор шаблонов, которые можно использовать для реализации этих интерфейсов.

### Модели собственности
Традиционная многоуровневая архитектура может вызвать проблемы при эффективной доставке программного обеспечения. 
На рис. 14-1 мы видим пример, в котором ответственность за уровень пользовательского интерфейса принадлежит одной 
фронтенд-группе, а работу по бэкэнд-сервисам выполняет другая. В этом примере добавление простого элемента управления 
предполагает работу, выполняемую тремя разными командами. Подобные многоуровневые организационные структуры могут 
существенно повлиять на скорость реализации из-за необходимости постоянно координировать изменения и передавать работу 
между командами.

Модель, которую я предпочитаю и которая, по моему мнению, лучше соответствует цели независимого развертывания, 
состоит в том, чтобы пользовательский интерфейс был разбит на части и управлялся командой, которая также управляет 
компонентами на стороне сервера, как мы видим на рис. 14-2. В данном случае за все изменения, которые нам необходимо 
внести для добавления нового элемента управления, отвечает одна команда.
Команды, полностью владеющие комплексной функциональностью, могут вносить изменения быстрее. Наличие полного владения 
побуждает каждую команду иметь прямой контакт с конечным пользователем программного обеспечения. При работе с 
бэкэнд-командами легко потерять представление о том, кто является конечным пользователем.
Несмотря на недостатки, я (к сожалению) по-прежнему считаю, что выделенная команда внешнего интерфейса является наиболее 
распространенной организационной структурой среди компаний, использующих микросервисы. Почему это

Драйверы для выделенных фронтенд-команд
Потребность в специализированных фронтенд-командах, похоже, сводится к трем ключевым факторам: нехватке специалистов, 
стремлению к последовательности и техническим проблемам. Во-первых, создание пользовательского интерфейса требует 
определенных специализированных навыков. Есть аспекты взаимодействия и графического дизайна, а также технические ноу-хау, 
необходимые для обеспечения отличного взаимодействия с веб-приложениями или собственными приложениями. Специалистов с 
такими навыками может быть трудно найти, и, поскольку эти люди настолько редки, возникает искушение объединить их всех, 
чтобы вы могли быть уверены, что они сосредоточены только на своей специальности.
Второй движущей силой отдельной фронтенд-команды является последовательность. Если у вас есть одна команда, ответственная 
за создание пользовательского интерфейса, ориентированного на клиента, вы можете обеспечить единообразный внешний 
вид вашего пользовательского интерфейса. Для решения аналогичных задач вы используете согласованный набор элементов 
управления, чтобы пользовательский интерфейс выглядел и воспринимался как единый целостный объект.

Наконец, с некоторыми технологиями пользовательского интерфейса может быть сложно работать немонолитно. Здесь я имею 
в виду конкретно одиночные приложения (SPA), которые, по крайней мере, исторически было нелегко разбить на части. 
Традиционно веб-интерфейс пользователя состоит из нескольких веб-страниц, и вы можете переходить с одной страницы на другую. 
При использовании SPA все приложение обслуживается на одной веб-странице. Такие фреймворки, как Angular, React и Vue, 
теоретически позволяют создавать более сложные пользовательские интерфейсы, чем «старомодные» веб-сайты. Далее в этой 
главе мы рассмотрим набор шаблонов, которые могут предоставить вам различные варианты декомпозиции 
пользовательского интерфейса, а с точки зрения SPA я покажу, как концепция микроинтерфейса может позволить вам 
использовать инфраструктуры SPA. при этом избегая необходимости в монолитном пользовательском интерфейсе

На пути к слаженным командам
Я думаю, что наличие выделенной команды внешнего интерфейса в целом является ошибкой, если вы пытаетесь оптимизировать 
производительность: это создает новые точки передачи управления в вашей организации, замедляя работу. В идеале наши 
команды концентрируются вокруг комплексных фрагментов функциональности, что позволяет каждой команде предоставлять 
новые функции своим клиентам, одновременно сокращая объем необходимой координации. Моя предпочтительная модель — 
это команда, владеющая сквозной доставкой функциональности в определенной части домена. Это соответствует тому, что 
Мэтью Скелтон и Мануэль Паис описывают как команды, ориентированные на потоки, в своей книге «Топологии команд».
1
Как они это описывают:
Команда, ориентированная на поток, — это команда, ориентированная на единый, ценный поток работы... эта команда имеет 
право создавать и доставлять ценность для клиентов или пользователей настолько быстро, безопасно и независимо, 
насколько это возможно, не требуя ручного управления. другим командам для выполнения части работы.
В каком-то смысле мы говорим о командах полного стека (а не о разработчиках полного стека). Команда, несущая 
сквозную ответственность за предоставление функциональности, ориентированной на пользователя, также будет иметь 
более очевидную и прямую связь с конечным пользователем. Слишком часто я видел «бэкэнд-команды» с туманным 
представлением о том, что делает программное обеспечение или что нужно пользователям, что может вызвать всевозможные 
недоразумения, когда дело доходит до реализации новых функций. С другой стороны, сквозным командам будет гораздо 
проще построить прямую связь с людьми, использующими создаваемое ими программное обеспечение, — они смогут больше 
сосредоточиться на том, чтобы люди, которых они обслуживают, получали то, что им нужно.






[к оглавлению](#SOLID)


## S - Single Responsibility Principle

Допустим у нас есть класс RentCarService и в нем есть несколько методов: найти машину по номеру, забронировать машину, 
распечатать заказ, получить информацию о машине, отправить сообщение.

```java
public class RentCarService {

    public Car findCar(String carNo) {
        //find car by number
        return car;
    }

    public Order orderCar(String carNo, Client client) {
        //client order car
        return order;
    }

    public void printOrder(Order order) {
        //print order
    }
    public void getCarInterestInfo(String carType) {
        if (carType.equals("sedan")) {
            //do some job
        }
        if (carType.equals("pickup")) {
            //do some job
        }
        if (carType.equals("van")) {
            //do some job
        }
    }
    public void sendMessage(String typeMessage, String message) {
        if (typeMessage.equals("email")) {
            //write email
            //use JavaMailSenderAPI
        }
    }
}
```

У данного класса есть несколько зон ответственности, что является нарушением первого принципа. Возьмем метод получения информации об машине. Теперь у нас есть только три типа машин sedan, pickup и van, но если Заказчик захочет добавить еще несколько типов, тогда придется изменять и дописывать данный метод.

Или возьмем метод отправки сообщения. Если кроме отправки сообщения по электронной почте необходимо будет добавить отправку смс, то также необходимо будет изменять данный метод.

Одним словом, данный класс нарушает принцип единой ответственности, так как отвечает за разные действия.

Необходимо разделить данный класс RentCarService на несколько, и тем самым, следуя принципу единой ответственности, предоставить каждому классу отвечать только за одну зону или действие, так в дальнейшем его будет проще дополнять и модифицировать.

Необходимо создать класс PrinterService и вынести там функционал по печати.

```java
public class PrinterService {
    public void printOrder(Order order) {
        //print order
    }
}
```

Аналогично работа связанная с поиском информации о машине перенести в класс CarInfoService.

```java
public class CarInfoService {
    public void getCarInterestInfo(String carType) {
        if (carType.equals("sedan")) {
            //do some job
        }
        if (carType.equals("pickup")) {
            //do some job
        }
        if (carType.equals("van")) {
            //do some job
        }
    }
}
```

Метод по отправке сообщений перенести в класс NotificationService. А метод поиска машины в CarService.

Теперь каждый класс несет ответственность только за одну зону и есть только одна причина для его изменения.

[к оглавлению](#solid)

## O - Open closed Principle

Класс по отправке сообщений:

```java
public class NotificationService {
    public void sendMessage(String typeMessage, String message) {
        if (typeMessage.equals("email")) {
            //write email
            //use JavaMailSenderAPI
        }
    }
}
```

Допустим нам необходимо кроме отправки сообщения по электронной почте отправлять еще смс сообщения. И мы можем дописать метод sendMessage таким образом:

```java
public class NotificationService {
    public void sendMessage(String typeMessage, String message) {
        if (typeMessage.equals("email")) {
            //write email
            //use JavaMailSenderAPI
        }
        if (typeMessage.equals("sms")) {
            //write sms
            //send sms
        }

    }
}
```

Но в данном случае мы нарушим второй принцип, потому что класс должен быть закрыт для модификации, 
но открыт для расширения, а мы модифицируем (изменяем) метод.

Для того чтобы придерживаться принципа открытости-закрытости нам необходимо спроектировать наш код таким образом, 
чтобы каждый мог повторно использовать нашу функцию, просто расширив ее. Поэтому создадим интерфейс 
NotificationService и в нем поместим метод sendMessage.

```java
public interface NotificationService {
    void sendMessage(String message);
}
```

Далее создадим класс EmailNotification, который имплементит интерфейс NotificationService и реализует
метод отправки сообщений по электронной почте.

```java
public class EmailNotification implements NotificationService{
    @Override
    public void sendMessage(String message) {
        //write email
        //use JavaMailSenderAPI
    }
}
```

Создадим аналогично класс MobileNotification, который будет отвечать за отправку смс сообщений.

```java
public class MobileNotification implements NotificationService{
    @Override
    public void sendMessage(String message) {
        //write sms
        //send sms
    }
}
```

Проектируя таким образом код мы не будем нарушать принцип открытости-закрытости, так как мы расширяем нашу 
функциональность, а не изменяем (модифицируем) наш класс.

[к оглавлению](#solid)

## L - Liskov substitution Principle

Данный принцип непосредственно связан с наследованием классов. Допустим у нас есть базовый класс Счет (Account), 
в котором есть три метода: просмотр остатка на счете, пополнение счета и оплата.

```java
public class Account {
    public BigDecimal balance(String numberAccount){
        //logic
        return bigDecimal;
    }
    public void refill(String numberAccount, BigDecimal sum){
        //logic
    }
    public void payment(String numberAccount, BigDecimal sum){
        //logic
    }
}
```

Нам необходимо написать еще два класса: зарплатный счет и депозитный счет, при этом зарплатный счет должен поддерживать 
все операции, представленные в базовом классе, а депозитный счет - не должен поддерживать проведение оплаты.

Если сейчас в коде программы везде, где мы использовали класс Account заменить на его класс-наследник (подтип) SalaryAccount, то программа продолжит нормально работать, так как в классе SalaryAccount доступны все операции, которые есть и в классе Account.

Если же мы такое попробуем сделать с классом DepositAccount, то есть заменим базовый класс Account на его класс-наследник DepositAccount, то программа начнет неправильно работать, так как при вызове метода payment() будет выбрасываться исключение new UnsupportedOperationException. Таким образом произошло нарушение принципа подстановки Барбары Лисков.

Для того чтобы следовать принципу подстановки Барбары Лисков необходимо в базовый (родительский) класс выносить только общую логику, характерную для классов наследников, которые будут ее реализовывать и, соответственно, можно будет базовый класс без проблем заменить на его класс-наследник.

В нашем случае класс Account будет выглядеть следующим образом.

```java
public class Account {
    public BigDecimal balance(String numberAccount){
        //logic
        return bigDecimal;
    }
    public void refill(String numberAccount, BigDecimal sum){
        //logic
    }
}
```

Мы сможем от него наследовать класс DepositAccount.

```java
public class DepositAccount extends Account{
    @Override
    public BigDecimal balance(String numberAccount){
        //logic
        return bigDecimal;
    }
    @Override
    public void refill(String numberAccount, BigDecimal sum){
        //logic
    }
}
```

Создадим дополнительный класс PaymentAccount, который унаследуем от Account и его расширим методом проведения оплаты.

```java
public class PaymentAccount extends Account{
    public void payment(String numberAccount, BigDecimal sum){
        //logic
    }
}
```

И наш класс SalaryAccount уже унаследуем от класса PaymentAccount.

```java
public class SalaryAccount extends PaymentAccount{
    @Override
    public BigDecimal balance(String numberAccount){
        //logic
        return bigDecimal;
    }
    @Override
    public void refill(String numberAccount, BigDecimal sum){
        //logic
    }
    @Override
    public void payment(String numberAccount, BigDecimal sum){
        //logic
    }
}
```

Сейчас замена класса PaymentAccount на его класс-наследник SalaryAccount не "поломает" нашу программу, так как класс SalaryAccount имеет доступ ко всем методам, что и PaymentAccount. Также все будет хорошо при замене класса Account на его класс-наследник PaymentAccount.

Принцип подстановки Барбары Лисков заключается в правильном использовании отношения наследования. Мы должны создавать наследников какого-либо базового класса тогда и только тогда, когда они собираются правильно реализовать его логику, не вызывая проблем при замене родителей на наследников.

[к оглавлению](#solid)

## I -  Interface Segregation Principle

Допустим у нас имеется интерфейс Payments и в нем есть три метода: оплата WebMoney, оплата банковской карточкой и оплата по номеру телефона.

```java
public interface Payments {
    void payWebMoney();
    void payCreditCard();
    void payPhoneNumber();
}
```

Далее нам надо реализовать два класса-сервиса, которые будут у себя реализовывать различные виды проведения
оплат (класс InternetPaymentService и TerminalPaymentService). При этом TerminalPaymentService не 
будет поддерживать проведение оплат по номеру телефона. Но если мы оба класса имплементим от интерфейса Payments, 
то мы будем "заставлять" TerminalPaymentService реализовывать метод, который ему не нужен.

Таким образом произойдет нарушение принципа разделения интерфейсов.

Для того чтобы этого не происходило необходимо разделить наш исходный интерфейс Payments на несколько и, создавая классы, имплементить в них только те интерфейсы с методами, которые им нужны.

```java
public interface WebMoneyPayment {
    void payWebMoney();
}

public interface CreditCardPayment {
    void payCreditCard();
}

public interface PhoneNumberPayment {
    void payPhoneNumber();
}

public class InternetPaymentService implements WebMoneyPayment,
        CreditCardPayment,
        PhoneNumberPayment{
    @Override
    public void payWebMoney() {
        //logic
    }
    @Override
    public void payCreditCard() {
        //logic
    }
    @Override
    public void payPhoneNumber() {
        //logic
    }
}

public class TerminalPaymentService implements WebMoneyPayment, CreditCardPayment{
    @Override
    public void payWebMoney() {
        //logic
    }
    @Override
    public void payCreditCard() {
        //logic
    }
}
```

[к оглавлению](#solid)

## D - Dependency Inversion Principle

Допустим мы пишем приложение для магазина и решаем вопросы с проведением оплат. Вначале это просто небольшой магазин, 
где оплата происходит только за наличные. Создаем класс Cash и класс Shop.

```java
public class Cash {
    public void doTransaction(BigDecimal amount){
        //logic
    }
}

public class Shop {
    private Cash cash;
    public Shop(Cash cash) {
        this.cash = cash;
    }
    public void doPayment(Object order, BigDecimal amount){
        cash.doTransaction(amount);
    }
}
```

Вроде все хорошо, но мы уже нарушили принцип инверсии зависимостей, так как мы тесно связали оплату наличными к нашему магазину. И если в дальнейшем нам необходимо будет добавить оплату еще банковской картой и телефоном ("100% понадобится"), то нам придется переписывать и изменять много кода. Мы в нашем коде модуль верхнего уровня тесно связали с модулем нижнего уровня, а нужно чтобы оба уровня зависели от абстракции.

Поэтому создадим интерфейс Payments.

```java
public interface Payments {
    void doTransaction(BigDecimal amount);
}
```

Теперь все наши классы по оплате будут имплементить данный интерфейс.

```java
public class Cash implements Payments{
    @Override
    public void doTransaction(BigDecimal amount) {
        //logic
    }
}

public class BankCard implements Payments{
    @Override
    public void doTransaction(BigDecimal amount) {
        //logic
    }
}

public class PayByPhone implements Payments {
    @Override
    public void doTransaction(BigDecimal amount) {
        //logic 
    }
}
```

Теперь надо перепроектировать реализацию нашего магазина.

```java
public class Shop {
    private Payments payments;

    public Shop(Payments payments) {
        this.payments = payments;
    }

    public void doPayment(Object order, BigDecimal amount){
        payments.doTransaction(amount);
    }
}
```

Сейчас наш магазин слабо связан с системой оплаты, то есть он зависит от абстракции и уже не важно каким способом оплаты будут пользоваться (наличными, картой или телефоном) все будет работать.

[к оглавлению](#solid)

[Вопросы для собеседования](/README.md)