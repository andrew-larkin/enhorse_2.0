[Вопросы для собеседования](README.md)

# 12 factor app
+ [Методология](#Методология)
+ [1. Codebase (кодовая база)](#1-Codebase-кодовая-база)
+ [2. Dependencies](#2-Dependencies-Зависимости)
+ [3. Config](#Как-отсортировать-список-строк-с-помощью-лямбда-выражения)
+ [Что такое «ссылка на метод»?](#Что-такое-ссылка-на-метод)
+ [Какие виды ссылок на методы вы знаете?](#Какие-виды-ссылок-на-методы-вы-знаете)
+ [Объясните выражение `System.out::println`.](#Объясните-выражение-systemoutprintln)
+ [Что такое «функциональные интерфейсы»?](#Что-такое-функциональные-интерфейсы)


## Методология

В наши дни программное обеспечение обычно распространяется в виде сервисов, называемых веб-приложения (web apps) 
или software-as-a-service (SaaS). Приложение двенадцати факторов — это методология для создания SaaS-приложений, которые:
+ Используют декларативный формат для описания процесса установки и настройки, что сводит к минимуму затраты времени и 
ресурсов для новых разработчиков, подключённых к проекту;
+ Имеют соглашение с операционной системой, предполагающее максимальную переносимость между средами выполнения;
+ Подходят для развёртывания на современных облачных платформах, устраняя необходимость в серверах и системном администрировании;
+ Сводят к минимуму расхождения между средой разработки и средой выполнения, что позволяет использовать 
непрерывное развёртывание (continuous deployment) для максимальной гибкости;
+ И могут масштабироваться без существенных изменений в инструментах, архитектуре и практике разработки.

Методология двенадцати факторов может быть применена для приложений, написанных на любом языке программирования и 
использующих любые комбинации сторонних служб (backing services) (базы данных, очереди сообщений, кэш-памяти, и т.д.).

В этом документе обобщается весь наш опыт использования и наблюдения за самыми разнообразными SaaS-приложениями в дикой природе.
Документ является объединением трёх идеальных подходов к разработке приложений: уделение особого внимания динамике
органического роста приложения с течением времени, динамике сотрудничества разработчиков, работающих над кодовой базой
приложения, и устранение последствий эрозии программного обеспечения.

[к оглавлению](#12-factor-app)


## 1. Codebase (кодовая база)
+ **Одна кодовая база, отслеживаемая в системе контроля версий, – множество развёртываний**

Кодовая база – это один репозиторий (в централизованных системах контроля версий, как Subversion) или множество 
репозиториев, имеющих общие начальные коммиты (в децентрализованных системах контроля версий, как Git).

Всегда есть однозначное соответствие между кодовой базой и приложением:
+ Если есть несколько кодовых баз, то это не приложение — это распределённая система. Каждый компонент в распределённой 
системе является приложением и каждый компонент может индивидуально соответствовать двенадцати факторам;
+ Факт того, что несколько приложений совместно используют тот же самый код, является нарушением двенадцати факторов. 
Решением в данной ситуации является выделение общего кода в библиотеки, которые могут быть подключены через менеджер зависимостей.

Существует только одна кодовая база для каждого приложения, но может быть множество развёртываний одного и 
того же приложения. Развёрнутым приложением (deploy) является запущенный экземпляр приложения. Как правило, 
это рабочее развёртывание сайта и одно или несколько промежуточных развёртываний сайта. Кроме того каждый разработчик 
имеет копию приложения, запущенного в его локальном окружении разработки, каждая из которых также квалифицируется 
как развёрнутое приложение (deploy).

Кодовая база обязана быть единой для всех развёртываний, однако разные версии одной кодовой базы могут выполняться 
в каждом из развёртываний. Например разработчик может иметь некоторые изменения которые ещё не добавлены в
промежуточное развёртывание; промежуточное развёртывание может иметь некоторые изменения, которые ещё не добавлены 
в рабочее развёртывание. Однако, все эти развёртывания используют одну и ту же кодовую базу, таким образом можно их 
идентифицировать как разные развёртывания одного и того же приложения.

[к оглавлению](#12-factor-app)

## 2. Dependencies (Зависимости)

+ **Явно объявляйте и изолируйте зависимости**

Приложение двенадцати факторов никогда не зависит от неявно существующих, доступных всей системе пакетов. 
Приложение объявляет все свои зависимости полностью и точно с помощью манифеста декларации зависимостей. Кроме того, 
оно использует инструмент изоляции зависимостей во время выполнения для обеспечения того, что неявные зависимости не 
“просочились” из окружающей системы. Полная и явная спецификация зависимостей применяется равным образом как при 
разработке, так и при работе приложения.

[к оглавлению](#12-factor-app)

## 3. Config (Конфигурация)

+ **Сохраняйте конфигурацию в среде выполнения**


Если существующий в классе метод уже делает все, что необходимо, то можно воспользоваться механизмом __method reference (ссылка на метод)__ для непосредственной передачи этого метода. Такая ссылка передается в виде:

+ `имя_класса::имя_статического_метода` для статического метода;
+ `объект_класса::имя_метода` для метода экземпляра;
+ `название_класса::new` для конструктора.

Результат будет в точности таким же, как в случае определения лямбда-выражения, которое вызывает этот метод.

```java
private interface Measurable {
    public int length(String string);
}

public static void main(String[] args) {
    Measurable a = String::length;
    System.out.println(a.length("abc"));
}
```

Ссылки на методы потенциально более эффективны, чем использование лямбда-выражений. Кроме того, они предоставляют компилятору более качественную информацию о типе и при возможности выбора между использованием ссылки на существующий метод и использованием лямбда-выражения, следует всегда предпочитать использование ссылки на метод.

[к оглавлению](#java-8)

## Какие виды ссылок на методы вы знаете?
+ на статический метод;
+ на метод экземпляра;
+ на конструкторе.

[к оглавлению](#java-8)

## Объясните выражение `System.out::println`.
Данное выражение иллюстрирует механизм _instance method reference_: передачи ссылки на метод `println()` статического поля `out` класса `System`.

[к оглавлению](#java-8)

## Что такое «функциональные интерфейсы»?
__Функциональный интерфейс__ - это интерфейс, который определяет только один абстрактный метод. 

Чтобы точно определить интерфейс как функциональный, добавлена аннотация `@FunctionalInterface`, работающая по принципу `@Override`. Она обозначит замысел и не даст определить второй абстрактный метод в интерфейсе.

Интерфейс может включать сколько угодно `default` методов и при этом оставаться функциональным, потому что `default` методы - не абстрактные.

[к оглавлению](#java-8)


+ `DoubleConsumer` - потребитель, получающий на вход `Double`;
+ `IntConsumer` - потребитель, получающий на вход `Integer`;
+ `LongConsumer` - потребитель, получающий на вход `Long`.

[к оглавлению](#java-8)

## Для чего нужны функциональные интерфейсы `Supplier<T>`,  `BooleanSupplier`, `DoubleSupplier`, `IntSupplier` и `LongSupplier`?
__`Supplier<T>` (поставщик)__ - интерфейс, с помощью которого реализуется функция, ничего не принимающая на вход, но возвращающая на выход результат класса `T`;

```java
Supplier<LocalDateTime> now = LocalDateTime::now;
now.get();
```

+ `DoubleSupplier` - поставщик, возвращающий `Double`;
+ `IntSupplier` - поставщик, возвращающий `Integer`;
+ `LongSupplier` - поставщик, возвращающий `Long`.

[к оглавлению](#java-8)

## Для чего нужен функциональный интерфейс `BiConsumer<T,U>`?
__`BiConsumer<T,U>`__ представляет собой операцию, которая принимает два аргумента классов `T` и `U` производит с ними некоторое действие и ничего не возвращает.

[к оглавлению](#java-8)

## Для чего нужен функциональный интерфейс `BiFunction<T,U,R>`?
__`BiFunction<T,U,R>`__ представляет собой операцию, которая принимает два аргумента классов `T` и `U` и возвращающая результат класса `R`.



# Источники
+ [Хабрахабр - Новое в Java 8](https://habrahabr.ru/post/216431/)
+ [Хабрахабр - Шпаргалка Java программиста 4. Java Stream API](https://habrahabr.ru/company/luxoft/blog/270383/)
+ [METANIT.COM](http://metanit.com/java/tutorial/9.1.php)
+ [javadevblog.com](http://javadevblog.com/interfejsy-v-java-8-staticheskie-metody-metody-po-umolchaniyu-funktsional-ny-e-interfejsy.html)

[Вопросы для собеседования](README.md)
