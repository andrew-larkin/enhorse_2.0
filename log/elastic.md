[Назад](logmenu.md)

# Elastic Search
+ [Что такое ElasticSearch?](#Что-такое-ElasticSearch)
+ [Каковы преимущества ElasticSearch?](#Каковы-преимущества-ElasticSearch)
+ [Для чего используется ElasticSearch?](#Для-чего-используется-ElasticSearch)
+ [Как работает ElasticSearch?](#Как-работает-ElasticSearch)
+ [Перечислите различные типы данных ElasticSearch для полей документа](#Перечислите-различные-типы-данных-ElasticSearch-для-полей-документа)
+ [Как остановить запуск службы поиска ElasticSearch на сервере Linux?](#Как-остановить-запуск-службы-поиска-ElasticSearch-на-сервере-Linux)
+ [Что такое ElasticSearch Mapping?](#Что-такое-ElasticSearch-Mapping)
+ [Что такое ElasticSearch fuzzy search?](#Что-такое-ElasticSearch-fuzzy-search)
+ [Что такое кластер в ElasticSearch?](#Что-такое-кластер-в-ElasticSearch)
+ [Node in ElasticSearch?](#Node-in-ElasticSearch)
+ [Document in ElasticSearch?](#Document-in-ElasticSearch)
+ [Какие операции можно выполнять с документом?](#Какие-операции-можно-выполнять-с-документом)
+ [Что такое индекс в ElasticSearch?](#Что-такое-индекс-в-ElasticSearch)
+ [Определите термины Shard и Replica в ElasticSearch](#В-чем-отличие-класса-printwriter-от-printstream)
+ [Каков процесс удаления индекса в Elasticsearch?](#Чем-отличаются-и-что-общего-у-inputstream-outputstream-reader-writer)
+ [Как добавить mapping в индекс?](#Какие-классы-позволяют-преобразовать-байтовые-потоки-в-символьные-и-обратно)
+ [Что подразумевается под термином type в ElasticSearch?](#Какие-классы-позволяют-ускорить-чтениезапись-за-счет-использования-буфера)
+ [Что подразумевается под NRT (поиск в реальном времени) в ElasticSearch?](#Какой-класс-предназначен-для-работы-с-элементами-файловой-системы)
+ [Tokenizer in ElasticSearch](#Какие-методы-класса-file-вы-знаете)
+ [Analyzer ElasticSearch](#Что-вы-знаете-об-интерфейсе-filefilter)
+ [Inverted index in ElasticSearch](#Как-выбрать-все-элементы-определенного-каталога-по-критерию-например-с-определенным-расширением)
+ [Функциональность cat API в ElasticSearch.](#Что-вы-знаете-о-randomaccessfile)
+ [Какие команды ElasticSearch доступны в cat API?](#Какие-режимы-доступа-к-файлу-есть-у-randomaccessfile)
+ [Объяснить стек ELK и его архитектуру](#Какие-классы-поддерживают-чтение-и-запись-потоков-в-компрессированном-формате)
+ [Какие инструменты управления конфигурацией поддерживает Elasticsearch?](#Существует-ли-возможность-перенаправить-потоки-стандартного-вводавывода)
+ [Необходимо ли устанавливать X-Pack для Elasticsearch? Каковы некоторые основные команды X-pack?](#Какой-символ-является-разделителем-при-указании-пути-в-файловой-системе)
+ [Aggregation in ElasticSearch](#Что-такое-абсолютный-путь-и-относительный-путь)
+ [Есть ли у ElasticSearch схема?](#Что-такое-символьная-ссылка)
+ [Как мы можем выполнить поиск в Elasticsearch?](#Какой-символ-является-разделителем-при-указании-пути-в-файловой-системе)
+ [Query DSL in ElasticSearch](#Что-такое-абсолютный-путь-и-относительный-путь)
+ [Какие типы запросов поддерживает ElasticSearch?](#Что-такое-символьная-ссылка)
+ [Каковы преимущества шардинга в Elasticsearch?](#Какой-символ-является-разделителем-при-указании-пути-в-файловой-системе)
+ [Каковы преимущества реплик в Elasticsearch?](#Что-такое-абсолютный-путь-и-относительный-путь)
+ [Routing in Elasticsearch](#Что-такое-символьная-ссылка)
+ [Что такое Ingest Node в ElasticSearch?](#Какие-подклассы-класса-writer-вы-знаете-для-чего-они-предназначены)


[к оглавлению](#Elastic-search)

## Что такое ElasticSearch?
Elasticsearch — это современная распределенная аналитическая поисковая система, построенная на Apache Lucene. ElasticSearch 
позволяет хранить, искать и анализировать огромные объемы данных практически в реальном времени, предоставляя результаты 
за миллисекунды. Elasticsearch, один из столпов Elastic Stack, представляет собой бесплатный и открытый набор инструментов 
для приема, хранения, обогащения, анализа и визуализации данных. Задержка между моментом индексации документа и моментом 
начала поиска в ElasticSearch чрезвычайно мала — обычно одна секунда. В отличие от большинства баз данных NoSQL, 
Elasticsearch NoSQL больше фокусируется на возможностях поиска и предоставляет богатый HTTP RESTful API, который позволяет 
осуществлять быстрый поиск практически в реальном времени.

[к оглавлению](#Elastic-search)

## Каковы преимущества ElasticSearch?
+ Elasticsearch — это быстрая поисковая система: поскольку Elasticsearch построен на базе Apache Lucene, он обеспечивает 
полнотекстовый поиск. Задержка между моментом индексации документа и моментом начала поиска в ElasticSearch чрезвычайно мала — 
обычно одна секунда. Это делает Elasticsearch хорошим выбором для срочных случаев использования, таких как мониторинг 
инфраструктуры и анализ безопасности.
+ Elasticsearch — это распределенная поисковая система: Elasticsearch хранит или распределяет документы по нескольким 
контейнерам, называемым сегментами, которые дублируются для обеспечения избыточных копий данных в случае сбоя оборудования 
или системы. Благодаря распределенному характеру Elasticsearch может масштабироваться до тысяч серверов и обрабатывать 
петабайты данных. Можно использовать ElasticSearch в качестве замены хранилищ документов, таких как RavenDB и MongoDB.
+ Elasticsearch предоставляет широкий спектр функций: помимо масштабируемости, скорости и отказоустойчивости, Elasticsearch 
предлагает множество встроенных функций, таких как объединение данных и управление жизненным циклом индекса, которые 
упрощают и повышают эффективность хранения и поиска данных.
+ Прием данных, визуализация и отчетность упрощаются с помощью Elastic Stack или BELEK: данные можно легко собирать и 
обрабатывать с помощью Beats и Logstash перед их индексацией в Elasticsearch. Помимо визуализации данных Elasticsearch в 
реальном времени, Kibana предоставляет пользовательский интерфейс для быстрого доступа к файлам журналов, мониторингу 
производительности приложений (APM) и данным показателей инфраструктуры.

[к оглавлению](#Elastic-search)

## Для чего используется ElasticSearch?
Скорость и масштабируемость Elasticsearch, а также его способность индексировать различные типы данных делают его 
идеальным для ряда случаев использования. Помимо высокой масштабируемости, Elasticsearch также предлагает возможности 
поиска практически в реальном времени. Все это составляет решение, которое предлагает гораздо больше, чем 
просто поисковую систему, и поддерживает множество операционных и критически важных сценариев использования в бизнесе. 
Поскольку Elasticsearch обладает мощными возможностями поиска, он обычно является базовой технологией для приложений, 
требующих сложных требований к поиску. Ниже перечислены некоторые варианты использования ElasticSearch:

+ Поиск приложений, корпоративный поиск и поиск по веб-сайту.
+ Анализ данных журналов практически в реальном времени и с возможностью масштабирования.
+ Бизнес-аналитика и аналитика безопасности.
+ Анализ и визуализация геопространственных данных.
+ Мониторинг производительности приложений.
+ Мониторинг показателей инфраструктуры и контейнеров

[к оглавлению](#Elastic-search)

## Как работает ElasticSearch?

1) Необработанные данные собираются из различных источников, таких как файлы журналов, системные метрики или веб-приложения. 
Beats — это легковесные агенты доставки данных (отправители данных), которые собирают различные типы данных и пересылают 
их в Logstash.
2) Эти необработанные данные нормализуются, анализируются и обогащаются перед индексацией в Elasticsearch. Logstash 
выполняет несколько преобразований и улучшений, а затем отправляет данные для индексации в Elasticsearch.
3) Как только данные проиндексированы в Elasticsearch, пользователи могут выполнять к ним запросы, а затем агрегировать 
их для получения аналитической информации. ElasticSearch позволяет хранить, искать и анализировать огромные объемы данных 
практически в реальном времени, предоставляя результаты за миллисекунды.
4) Наконец, с помощью Kibana пользователи могут создавать мощные средства визуализации данных и визуализировать сложные 
запросы с помощью интерактивных диаграмм, геопространственных данных и графиков.

[к оглавлению](#Elastic-search)

## Перечислите различные типы данных ElasticSearch для полей документа

Типы полей (также называемые типами данных поля) описывают тип информации или данных, содержащихся в поле, например 
строку или логическое значение, а также их предполагаемое использование. Ниже приведены некоторые типы данных для полей документа:

**Общие (Common) типы данных**:

- Binary: двоичное значение, закодированное как строка Base64.
- Boolean: истинное или ложное значение.
- Keywords: семейство ключевых слов, включающее ключевое слово, постоянное ключевое слово и подстановочный знак.
- Numbers: числовые типы, такие как длинные, двойные, с плавающей запятой, байты, целые числа и т. д.
- Dates: типы дат, такие как date_nano, date.
- Alias: представляет псевдоним существующего поля.

**Объекты и реляционные типы**:

- Object: представляет объект JSON.
- Nested: объект JSON, который поддерживает связь между своими подполями.
- Flattened: весь объект JSON, представленный одним значением поля.\
- Join: устанавливает родительские/дочерние отношения между документами в индексе.

**Структурированные и пространственные типы данных**:

- Range: типы диапазонов, такие как date_range, long_range, float_range, double_range, IP_range.
- Point: произвольные декартовы точки.
- Geo_point: точки долготы и широты.
- Shape: произвольная декартова геометрия.
- Geo_shape: сложные формы, такие как многоугольники.

[к оглавлению](#Elastic-search)

## Как остановить запуск службы поиска ElasticSearch на сервере Linux?
Чтобы закрыть или отключить службу Elasticsearch на сервере Linux, вам необходимо «убить» запущенный процесс. 
Это достигается путем отправки запроса SIGTERM процессу, который завершает или уничтожает его.

Чтобы инициировать процесс завершения работы, вы должны сначала определить идентификатор процесса (PID) для службы 
Elasticsearch, которую вы хотите завершить. Команду Grep можно использовать для быстрого поиска процессов. Если вы хотите 
найти все процессы, связанные с Elasticsearch, запущенные на сервере, вы можете использовать следующую команду:

`ps -ef | grep elas`

После определения правильного PID просто выполните команду kill с PID процесса Elasticsearch. После успешного выполнения 
команды kill Elasticsearch больше не должен работать.

[к оглавлению](#Elastic-search)

## Что такое ElasticSearch Mapping?
ElasticSearch Mapping определяет, как документы и их поля индексируются и хранятся в базах данных ElasticSearch или 
ElasticSearch DB. Оно определяет типы и форматы полей, которые появляются в документах. В результате Mapping может оказать 
существенное влияние на то, как Elasticsearch ищет и хранит данные. После создания индекса мы должны определить Mapping. 
Неверное предварительное определение и Mapping могут привести к неверным результатам поиска.

Типы Mapping:
- Статическое сопоставление. Пользователи выполняют статическое сопоставление при создании индекса. Мы используем 
статические сопоставления для определения типов данных и индексов. При создании индекса легко определить поля и их типы.
- Динамическое сопоставление: Elasticsearch автоматически создает динамические сопоставления для таблиц. Динамическое 
сопоставление Elasticsearch пригодится, когда нам нужно хранить дополнительные атрибуты в документах. Не всегда 
необходимо настраивать имена и типы полей при индексировании документов, поскольку они будут созданы Elasticsearch 
автоматически на основе любых предопределенных правил.

[к оглавлению](#Elastic-search)

## Что такое ElasticSearch fuzzy search?
С помощью нечеткого (fuzzy) поиска вы можете найти документы с терминами, похожими на ваш поисковый запрос, на основе меры 
расстояния редактирования Левенштейна (Levenshtein edit distance measure). Расстояние редактирования — это, по сути, 
количество односимвольных изменений или правок, необходимых для преобразования одного термина в другой. Среди этих изменений:

- Изменение одного символа (box → fox)
- Удаление одного символа (black → lack)
- Вставка одного символа (sic → sick)
- Транспонирование двух соседних символов (act → cat)

В пределах определенного расстояния редактирования нечеткий запрос генерирует список всех возможных вариантов и расширений 
поискового запроса. После этого запрос возвращает список всех возможных совпадений. Наиболее релевантные и точные совпадения 
отображаются в верхней части списка.

[к оглавлению](#Elastic-search)

## Что такое кластер в ElasticSearch?
Кластер — это совокупность связанных узлов. Если вы запускаете только один экземпляр или узел Elasticsearch, то у вас есть 
кластер с одним узлом или кластер из одного узла. Кластеры автоматически реорганизуются при присоединении или выходе узлов, 
поэтому данные распределяются равномерно между всеми узлами. Несмотря на полную функциональность кластера, в случае его 
сбоя существует риск потери данных.

[к оглавлению](#Elastic-search)

## Node in ElasticSearch?
Вы можете думать об узле как об одном сервере, который является частью вашего кластера. Узлам назначаются роли, 
описывающие их обязанности и операции. По умолчанию каждый узел кластера может обрабатывать HTTP и транспортный трафик. 
Связь между узлами осуществляется через транспортный уровень, а клиенты REST используют уровень HTTP. Узлы в кластере 
знают друг о друге и могут перенаправлять запросы клиентов на нужный узел.

[к оглавлению](#Elastic-search)

## Document in ElasticSearch
Термин «документ» относится к единице информации, которая может быть проиндексирована. Каждый индекс в Elasticsearch 
содержит несколько документов. Например, у вас может быть один документ для каждого клиента, другой для каждого заказа 
и т. д. Эти документы написаны в JSON. Документы состоят из полей, и каждое поле имеет свой тип данных. В определенном 
индексе вы можете хранить столько документов, сколько пожелаете.

[к оглавлению](#Elastic-search)

## Какие операции можно выполнять с документом?
Elasticsearch позволяет выполнять над документами следующие операции:

+ Индексирование (Indexing) документа
+ Получение (Fetching) документов
+ Обновление (Updating) документов
+ Удаление (Deleting) документов

[к оглавлению](#Elastic-search)

## Что такое индекс в ElasticSearch?
Индекс — это набор документов, которые в чем-то схожи по своей природе. Например, у вас может быть индекс данных о клиентах, 
еще один — каталогов продуктов и еще один — данных о заказах. Имя индекса (которое должно быть написано строчными буквами) 
служит идентификатором индекса при индексировании, поиске, обновлении и удалении содержащихся в нем документов. Индекс 
может иметь один или несколько shards и replicas.

<img src="https://d3n0h9tb65y8q.cloudfront.net/public_assets/assets/000/003/135/original/index_in_ElasticSearch.png?1651747190" alt="d" width="50%" height="50%">

[к оглавлению](#Elastic-search)

## В чем отличие класса `PrintWriter` от `PrintStream`?
Прежде всего, в классе `PrintWriter` применен усовершенствованный способ работы с символами Unicode и другой механизм буферизации вывода: в классе PrintStream буфер вывода сбрасывался всякий раз, когда вызывался метод `print()` или `println()`, а при использовании класса `PrintWriter` существует возможность отказаться от автоматического сброса буферов, выполняя его явным образом при помощи метода `flush()`.

Кроме того, методы класса `PrintWriter` никогда не создают исключений. Для проверки ошибок необходимо явно вызвать метод `checkError()`.

[к оглавлению](#Потоки-вводавывода-в-java)

## Чем отличаются и что общего у `InputStream`, `OutputStream`, `Reader`, `Writer`?
+ `InputStream` и его наследники - совокупность для получения байтовых данных из различных источников;
+ `OutputStream` и его наследники - набор классов, определяющих потоковый байтовый вывод;
+ `Reader` и его наследники определяют потоковый ввод символов Unicode;
+ `Writer` и его наследники определяют потоковый вывод символов Unicode.

[к оглавлению](#Потоки-вводавывода-в-java)

## Какие классы позволяют преобразовать байтовые потоки в символьные и обратно?
+ `OutputStreamWriter` — «мост» между классом `OutputStream` и классом `Writer`. Символы, записанные в поток, преобразовываются в байты.
+ `InputStreamReader` — аналог для чтения. При помощи методов класса `Reader` читаются байты из потока `InputStream` и далее преобразуются в символы.

[к оглавлению](#Потоки-вводавывода-в-java)

## Какие классы позволяют ускорить чтение/запись за счет использования буфера?
+ `BufferedInputStream(InputStream in)`/`BufferedInputStream(InputStream in, int size)`,
+ `BufferedOutputStream(OutputStream out)`/`BufferedOutputStream(OutputStream out, int size)`,
+ `BufferedReader(Reader r)`/`BufferedReader(Reader in, int sz)`,
+ `BufferedWriter(Writer out)`/`BufferedWriter(Writer out, int sz)`

[к оглавлению](#Потоки-вводавывода-в-java)

## Какой класс предназначен для работы с элементами файловой системы?
`File` работает непосредственно с файлами и каталогами. Данный класс позволяет создавать новые элементы и получать информацию существующих: размер, права доступа, время и дату создания, путь к родительскому каталогу.

[к оглавлению](#Потоки-вводавывода-в-java)

## Какие методы класса `File` вы знаете?
Наиболее используемые методы класса `File`:

+ `boolean createNewFile()`: делает попытку создать новый файл;
+ `boolean delete()`: делает попытку удалить каталог или файл;
+ `boolean mkdir()`: делает попытку создать новый каталог;
+ `boolean renameTo(File dest)`: делает попытку переименовать файл или каталог;
+ `boolean exists()`: проверяет, существует ли файл или каталог;
+ `String getAbsolutePath()`: возвращает абсолютный путь для пути, переданного в конструктор объекта;
+ `String getName()`: возвращает краткое имя файла или каталога;
+ `String getParent()`: возвращает имя родительского каталога;
+ `boolean isDirectory()`: возвращает значение `true`, если по указанному пути располагается каталог;
+ `boolean isFile()`: возвращает значение `true`, если по указанному пути находится файл;
+ `boolean isHidden()`: возвращает значение `true`, если каталог или файл являются скрытыми;
+ `long length()`: возвращает размер файла в байтах;
+ `long lastModified()`: возвращает время последнего изменения файла или каталога;
+ `String[] list()`: возвращает массив файлов и подкаталогов, которые находятся в определенном каталоге;
+ `File[] listFiles()`: возвращает массив файлов и подкаталогов, которые находятся в определенном каталоге.

[к оглавлению](#Потоки-вводавывода-в-java)

## Что вы знаете об интерфейсе `FileFilter`?
Интерфейс `FileFilter` применяется для проверки, попадает ли объект `File` под некоторое условие. Этот интерфейс содержит единственный метод `boolean accept(File pathName)`. Этот метод необходимо переопределить и реализовать. Например:

```java
public boolean accept(final File file) {
    return file.isExists() && file.isDirectory();
}
```

[к оглавлению](#Потоки-вводавывода-в-java)

## Как выбрать все элементы определенного каталога по критерию (например, с определенным расширением)?
Метод `File.listFiles()` возвращает массив объектов `File`, содержащихся в каталоге. Метод может принимать в качестве параметра объект класса, реализующего `FileFilter`. Это позволяет включить в список только те элементы, для которых метод `accept` возвращает `true` (критерием может быть длина имени файла или его расширение).

[к оглавлению](#Потоки-вводавывода-в-java)

## Что вы знаете о `RandomAccessFile`?
Класс `java.io.RandomAccessFile` обеспечивает чтение и запись данных в произвольном месте файла. Он не является частью иерархии `InputStream` или `OutputStream`. Это полностью отдельный класс, имеющий свои собственные (в большинстве своем _native_) методы. Объяснением этого может быть то, что `RandomAccessFile` имеет во многом отличающееся поведение по сравнению с остальными классами ввода/вывода так как позволяет, в пределах файла, перемещаться вперед и назад.

`RandomAccessFile` имеет такие специфические методы как:

+ `getFilePointer()` для определения текущего местоположения в файле;
+ `seek()` для перемещения на новую позицию в файле;
+ `length()` для выяснения размера файла;
+ `setLength()` для установки размера файла;
+ `skipBytes()` для того, чтобы попытаться пропустить определённое число байт;
+ `getChannel()` для работы с уникальным файловым каналом, ассоциированным с заданным файлом;
+ методы для выполнения обычного и форматированного вывода из файла (`read()`, `readInt()`, `readLine()`, `readUTF()` и т.п.);
+ методы для обычной или форматированной записи в файл с прямым доступом (`write()`, `writeBoolean()`, `writeByte()` и т.п.).

Так же следует отметить, что конструкторы `RandomAccessFile` требуют второй аргумент, указывающий необходимый режим доступа к файлу - только чтение (`"r"`), чтение и запись (`"rw"`) или иную их разновидность.

[к оглавлению](#Потоки-вводавывода-в-java)

## Какие режимы доступа к файлу есть у `RandomAccessFile`?
+ `"r"` открывает файл только для чтения. Запуск любых методов записи данных приведет к выбросу исключения `IOException`.
+ `"rw"` открывает файл для чтения и записи. Если файл еще не создан, то осуществляется попытка создать его.
+ `"rws"` открывает файл для чтения и записи подобно `"rw"`, но требует от системы при каждом изменении содержимого файла или метаданных синхронно записывать эти изменения на физический носитель.
+ `"rwd"` открывает файл для чтения и записи подобно `"rws"`, но требует от системы синхронно записывать изменения на физический носитель только при каждом изменении содержимого файла. Если изменяются метаданные, синхронная запись не требуется.

[к оглавлению](#Потоки-вводавывода-в-java)

## Какие классы поддерживают чтение и запись потоков в компрессированном формате?
+ `DeflaterOutputStream` - компрессия данных в формате deflate.
+ `Deflater` - компрессия данных в формат ZLIB
+ `ZipOutputStream` - потомок `DeflaterOutputStream` для компрессии данных в формат Zip.
+ `GZIPOutputStream` - потомок `DeflaterOutputStream` для компрессии данных в формат GZIP.
+ `InflaterInputStream` - декомпрессия данных в формате deflate.
+ `Inflater` - декомпрессия данных в формате ZLIB
+ `ZipInputStream` - потомок `InflaterInputStream` для декомпрессии данных в формате Zip.
+ `GZIPInputStream` - потомок `InflaterInputStream` для декомпрессии данных в формате GZIP.

[к оглавлению](#Потоки-вводавывода-в-java)

## Существует ли возможность перенаправить потоки стандартного ввода/вывода?
Класс `System` позволяет вам перенаправлять стандартный ввод, вывод и поток вывода ошибок, используя простой вызов статического метода:

+ `setIn(InputStream)` - для ввода;
+ `setOut(PrintStream)` - для вывода;
+ `setErr(PrintStream)` - для вывода ошибок.

[к оглавлению](#Потоки-вводавывода-в-java)

## Какой символ является разделителем при указании пути в файловой системе?
Для различных операционных систем символ разделителя различается. Для Windows это `\`, для Linux - `/`. 

В Java получить разделитель для текущей операционной системы можно через обращение к статическому полю `File.separator`.

[к оглавлению](#Потоки-вводавывода-в-java)

## Что такое _«абсолютный путь»_ и _«относительный путь»_?
__Абсолютный (полный) путь__ — это путь, который указывает на одно и то же место в файловой системе, вне зависимости от текущей рабочей директории или других обстоятельств. Полный путь всегда начинается с корневого каталога. 

__Относительный путь__ представляет собой путь по отношению к текущему рабочему каталогу пользователя или активного приложения.

[к оглавлению](#Потоки-вводавывода-в-java)

## Что такое _«символьная ссылка»_?
__Символьная (символическая) ссылка__ (также «симлинк», Symbolic link) — специальный файл в файловой системе, в котором, вместо пользовательских данных, содержится путь к файлу, который должен быть открыт при попытке обратиться к данной ссылке (файлу). Целью ссылки может быть любой объект: например, другая ссылка, файл, каталог или даже несуществующий файл (в последнем случае, при попытке открыть его, должно выдаваться сообщение об отсутствии файла).

Символьные ссылки используются для более удобной организации структуры файлов на компьютере, так как:

+ позволяют для одного файла или каталога иметь несколько имён и различных атрибутов;
+ свободны от некоторых ограничений, присущих жёстким ссылкам (последние действуют только в пределах одной файловой системы (одного раздела) и не могут ссылаться на каталоги).

[к оглавлению](#Потоки-вводавывода-в-java)

[Назад](logmenu.md)
